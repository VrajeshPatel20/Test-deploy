# -*- coding: utf-8 -*-
"""test_deploy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tbHfKKCUFCQgDKgbFzHScX_hcMEux7KY
"""

import pandas as pd
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.express as px
import requests
from bs4 import BeautifulSoup

# Step 1: Scrape FIFA World Cup Winners Data from Wikipedia
url = "https://en.wikipedia.org/wiki/List_of_FIFA_World_Cup_finals"
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')

html_table = soup.find_all('table', {'class': 'sortable plainrowheaders wikitable'})[0]  # Second table contains the data
table_rows = html_table.find_all('tr')[1:]

data = []
for row in table_rows:
    cols = row.find_all(['th', 'td'])
    year = cols[0].text.strip()
    winner = cols[1].text.strip()
    score = cols[2].text.strip()
    runner_up = cols[3].text.strip()
    venue = cols[4].text.strip()
    location = cols[5].text.strip()
    attendence = cols[6].text.strip()
    # To ensure that data does not have nulls
    if attendence:
      data.append({
          'Year':year,
          'Winner': winner,
          'Score':score,
          'Runner-Up':runner_up,
          'Venue':venue,
          'Location': location,
          'Attendence': attendence
      })

df = pd.DataFrame(data, columns=['Year', 'Winner','Score', 'Runner-Up', 'Venue', 'Location', 'Attendence'])

df

# Normalize country names (Germany and West Germany considered the same)
df.replace({'Winner': {'West Germany': 'Germany'}, 'Runner-Up': {'West Germany': 'Germany'}}, inplace=True)
# Remove world cups that are yet to happen
df.dropna(subset=['Winner'], inplace=True)

winner_counts = df['Winner'].value_counts().reset_index()
winner_counts.columns = ['Country', 'Wins']
print(winner_counts)

app = dash.Dash(__name__)
server = app.server
app.layout = html.Div([
    html.H1("FIFA World Cup Winners Visualization"),

    dcc.Graph(id='choropleth-map'),

    html.Label("Select a Country:"),
    dcc.Dropdown(
        id='country-dropdown',
        options=[{'label': c, 'value': c} for c in winner_counts['Country']],
        value=winner_counts['Country'][0],
        clearable=False
    ),
    html.Div(id='country-wins'),

    html.Label("Select a Year:"),
    dcc.Dropdown(
        id='year-dropdown',
        options=[{'label': y, 'value': y} for y in df['Year']],
        value=df['Year'][0],
        clearable=False
    ),
    html.Div(id='year-results')
])

# Step 3: Callbacks for interactivity
@app.callback(
    Output('choropleth-map', 'figure'),
    Input('country-dropdown', 'value')
)
def update_map(selected_country):
    fig = px.choropleth(
        winner_counts,
        locations='Country',
        locationmode='country names',
        color='Wins',
        title='World Cup Wins by Country',
        color_continuous_scale='Blues'
    )
    return fig

@app.callback(
    Output('country-wins', 'children'),
    Input('country-dropdown', 'value')
)
def display_wins(selected_country):
    wins = winner_counts.loc[winner_counts['Country'] == selected_country, 'Wins'].values[0]
    return html.H3(f"{selected_country} has won the World Cup {wins} times")

@app.callback(
    Output('year-results', 'children'),
    Input('year-dropdown', 'value')
)
def display_results(selected_year):
    row = df[df['Year'] == selected_year].iloc[0]
    return html.H3(f"{row['Year']}: Winner - {row['Winner']}, Runner-Up - {row['Runner-Up']}")

# Run the app
if __name__ == '__main__':
    app.run(debug=True)

